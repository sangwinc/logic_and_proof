<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-01-04 Wed 09:18 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Logic and Proof</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="[[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]]Jeremy Avigad, [[http://www.andrew.cmu.edu/user/rlewis1/][Robert Y. Lewis]]Robert Y. Lewis,  [[http://www.contrib.andrew.cmu.edu/~fpv/][Floris van Doorn]]Floris van Doorn" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/polymer.platform/0.4.2/platform.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
</head>
<body>
<div id="content">
<h1 class="title">Logic and Proof</h1>

<div id="outline-container-org5ba1520" class="outline-2">
<h2 id="Propositional_Logic_in_Lean"><a id="org5ba1520"></a><span class="section-number-2"> 4</span> Propositional Logic in Lean</h2>
<div class="outline-text-2" id="text-Propositional_Logic_in_Lean">
<p>
In this chapter, you will learn how to write proofs in Lean. We will
start with a purely mechanical translation that will enable you to
represent any natural deduction proof in Lean. We will see, however,
that such a style of writing proofs is not very intuitive, nor does it
yield very readable proofs. It also does not scale well.
</p>

<p>
We will then consider some mechanisms that Lean offers that support a
more forward-directed style of argumentation. Since these proofs look
more like informal proofs but can be directly translated to natural
deduction, they will help us understand the relationship between the
two.
</p>
</div>

<div id="outline-container-orgd2c439b" class="outline-3">
<h3 id="orgd2c439b"><span class="section-number-3"> 4.1</span> Expressions for Propositions and Proofs</h3>
<div class="outline-text-3" id="text-1-1">
<p>
At its core, Lean is what is known as a <i>type checker</i>. This means
that we can write expressions and ask the system to check that they
are well formed, and also ask the system to tell us what type of
object they denote. Try this:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-1' mode="ace/mode/lean" readonly="true">variables A B C : Prop

check A ∧ ¬ B → C
</juicy-ace-editor><div id='lean-full-code-1' style='display:none'>variables A B C : Prop

check A ∧ ¬ B → C
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-1').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In the online version of this text, you can press the "Try it
yourself" button to copy the example to the editor window, press the
"play" button, and then hover over the markers on the left to read the
messages.
</p>

<p>
In the example, we declare three variables ranging over propositions,
and ask Lean to check the expression <code>A ∧ ¬ B → C</code>. The output of the
<code>check</code> command is <code>A ∧ ¬ B → C : Prop</code>, which asserts that <code>A ∧ ¬ B →
C</code> is of type <code>Prop</code>. In Lean, every well-formed expression has a
type.
</p>

<p>
The logical connectives are rendered in unicode. The following chart
shows you how you can type these symbols in the editor, and also
provides ascii equivalents, for the purists among you.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Unicode</th>
<th scope="col" class="org-left">Ascii</th>
<th scope="col" class="org-left">Emacs</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">true</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">false</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">¬</td>
<td class="org-left">not</td>
<td class="org-left"><code>\not</code>, <code>\neg</code></td>
</tr>

<tr>
<td class="org-left">∧</td>
<td class="org-left">/\</td>
<td class="org-left"><code>\and</code></td>
</tr>

<tr>
<td class="org-left">‌∨</td>
<td class="org-left">\/</td>
<td class="org-left"><code>\or</code></td>
</tr>

<tr>
<td class="org-left">→</td>
<td class="org-left">-&gt;</td>
<td class="org-left"><code>\to</code>, <code>\r</code>, <code>\implies</code></td>
</tr>

<tr>
<td class="org-left">↔</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left"><code>\iff</code>, <code>\lr</code></td>
</tr>

<tr>
<td class="org-left">∀</td>
<td class="org-left">forall</td>
<td class="org-left"><code>\all</code></td>
</tr>

<tr>
<td class="org-left">∃</td>
<td class="org-left">exists</td>
<td class="org-left"><code>\ex</code></td>
</tr>

<tr>
<td class="org-left">λ</td>
<td class="org-left">fun</td>
<td class="org-left"><code>\l</code>, <code>\fun</code></td>
</tr>

<tr>
<td class="org-left">≠</td>
<td class="org-left">~=</td>
<td class="org-left"><code>\ne</code></td>
</tr>
</tbody>
</table>
<p>
So far, we have only talked about the first seven items on the
list. We will discuss the quantifiers, lambda, and equality later. Try
typing some expressions and checking them on your own. You should try
changing one of the variables in the example above to <code>D</code>, or
inserting a nonsense symbol into the expression, and take a look at
the error message that Lean returns.
</p>

<p>
In addition to declaring variables, if <code>P</code> is any expression of type
<code>Prop</code>, we can declare the hypothesis that <code>P</code> is true:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-2' mode="ace/mode/lean" readonly="true">variables A B : Prop
premise H : A ∧ ¬ B

check H
</juicy-ace-editor><div id='lean-full-code-2' style='display:none'>variables A B : Prop
premise H : A ∧ ¬ B

check H
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-2').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Formally, what is going on is that any proposition can be viewed as a
type, namely, the type of proofs of that proposition. A hypothesis, or
premise, is just a variable of that type. Building proofs is then a
matter of writing down expressions of the write type. For example, if
<code>P</code> is any expression of type <code>A ∧ B</code>, then <code>and.left P</code> is an
expression of type <code>A</code>, and <code>and.right P</code> is an expression of type
<code>B</code>. In other words, if <code>P</code> is a proof of <code>A ∧ B</code>, and <code>and.left P</code> is
a name for the proof you get by applying the left elimination rule for
and:
</p>

<div class="figure">
<p><img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_0146086e2a8b6da669e2598369b276ee36890cfa.png" alt="04_Propositional_Logic_in_Lean.org.temp_0146086e2a8b6da669e2598369b276ee36890cfa.png" /></p>
</div>
<p>
Similarly, <code>and.right P</code> is the proof of <code>B</code> you get by applying the
right elimination rule. So, continuing the example above, we can write
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-3' mode="ace/mode/lean" readonly="true">variables A B : Prop
premise H : A ∧ ¬ B

check and.left H
check and.right H
</juicy-ace-editor><div id='lean-full-code-3' style='display:none'>variables A B : Prop
premise H : A ∧ ¬ B

check and.left H
check and.right H
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-3').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The two expressions represent, respectively, these two proofs:
</p>

<div class="figure">
<p><img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_7ed7534a8111195c152ee94699256932ca52c53b.png" alt="04_Propositional_Logic_in_Lean.org.temp_7ed7534a8111195c152ee94699256932ca52c53b.png" /></p>
</div>
<p>
Notice that in this way of representing natural deduction proofs,
there are no "free floating" hypotheses. Every hypothesis has a
label. In Lean, we will typically use expressions like <code>H</code>, <code>H1</code>,
<code>H2</code>, &#x2026; to label hypotheses, but you can use any identifier you
want.
</p>

<p>
If <code>P₁</code> is a proof of <code>A</code> and <code>P₂</code> is a proof of <code>B</code>, then <code>and.intro
P₁ P₂</code> is a proof of <code>A ∧ B</code>. So we can continue the example above:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-4' mode="ace/mode/lean" readonly="true">variables A B : Prop
premise H : A ∧ ¬ B

check and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-4' style='display:none'>variables A B : Prop
premise H : A ∧ ¬ B

check and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-4').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This corresponds to the following proof:
</p>

<div class="figure">
<p><img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_4f9a872aa2bea70da548a954df2014b10df68ed8.png" alt="04_Propositional_Logic_in_Lean.org.temp_4f9a872aa2bea70da548a954df2014b10df68ed8.png" /></p>
</div>

<p>
What about implication? The elimination rule is easy: if <code>P₁</code> is a
proof of <code>A → B</code> and <code>P₂</code> is a proof of <code>A</code> then <code>P₁ P₂</code> is a proof of
<code>B</code>. Notice that we do not even need to name the rule: you just write
<code>P₁</code> followed by <code>P₂</code>, as though you are applying the first to the
second. If <code>P₁</code> and <code>P₂</code> are compound expressions, put parentheses
around them to make it clear where each one begins and ends.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-5' mode="ace/mode/lean" readonly="true">variables A B C D : Prop

premise H1 : A → (B → C)
premise H2 : D → A
premise H3 : D
premise H4 : B

check H2 H3
check H1 (H2 H3)
check (H1 (H2 H3)) H4
</juicy-ace-editor><div id='lean-full-code-5' style='display:none'>variables A B C D : Prop

premise H1 : A → (B → C)
premise H2 : D → A
premise H3 : D
premise H4 : B

check H2 H3
check H1 (H2 H3)
check (H1 (H2 H3)) H4
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-5').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Lean adopts the convention that applications associate to the
left, so that an expression <code>H1 H2 H3</code> is interpreted as <code>(H1 H2)
H3</code>. Implications associate to the <i>right</i>, so that <code>A → B → C</code> is
interpreted as <code>A → (B → C)</code>. This may seem funny, but it is a
convenient way to represent implications that take multiple
hypotheses, since an expression <code>A → B → C → D → E</code> means that <code>E</code>
follows from <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>. So the example above could be
written as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-6' mode="ace/mode/lean" readonly="true">variables A B C D : Prop

premise H1 : A → B → C
premise H2 : D → A
premise H3 : D
premise H4 : B

check H2 H3
check H1 (H2 H3)
check H1 (H2 H3) H4
</juicy-ace-editor><div id='lean-full-code-6' style='display:none'>variables A B C D : Prop

premise H1 : A → B → C
premise H2 : D → A
premise H3 : D
premise H4 : B

check H2 H3
check H1 (H2 H3)
check H1 (H2 H3) H4
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-6').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that parentheses are still needed in the expression <code>H1 (H2
H3)</code>.
</p>

<p>
The implication introduction rule is the tricky one, because it can
cancel a hypothesis. In terms of Lean expressions, the rule translates
as follows. Suppose <code>A</code> and <code>B</code> have type <code>Prop</code>, and, assuming <code>H</code> is
the premise that <code>A</code> holds, <code>P</code> is proof of <code>B</code>, possibly involving
<code>H</code>. Then the expression <code>assume H : A, P</code> is a proof of <code>A → B</code>. For
example, we can construct a proof of <code>A → A ∧ A</code> as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-7' mode="ace/mode/lean" readonly="true">variable A : Prop

check (assume H : A, and.intro H H)
</juicy-ace-editor><div id='lean-full-code-7' style='display:none'>variable A : Prop

check (assume H : A, and.intro H H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-7').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that we no longer have to declare <code>A</code> as a premise. The word
<code>assume</code> makes the premise local to the expression in parentheses, and
after the assumption is made, we can refer to <code>H</code>. Given the
assumption <code>H : A</code>, <code>and.intro H H</code> is a proof of <code>A ∧ A</code>, and so the
expression <code>assume H : A, and.intro H H</code> is a proof of <code>A → A ∧
A</code>. In this case, we could leave out the parentheses because the
expression is unambiguous:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-8' mode="ace/mode/lean" readonly="true">variable A : Prop

check assume H : A, and.intro H H
</juicy-ace-editor><div id='lean-full-code-8' style='display:none'>variable A : Prop

check assume H : A, and.intro H H
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-8').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Above, we proved <code>¬ B ∧ A</code> from the premise <code>A ∧ ¬ B</code>. We can instead
obtain a proof of <code>A ∧ ¬ B → ¬ B ∧ A</code> as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-9' mode="ace/mode/lean" readonly="true">variables A B : Prop
check (assume H : A ∧ ¬ B, and.intro (and.right H) (and.left H))
</juicy-ace-editor><div id='lean-full-code-9' style='display:none'>variables A B : Prop
check (assume H : A ∧ ¬ B, and.intro (and.right H) (and.left H))
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-9').text());">Try it yourself &raquo;</button></div>
</div>
<p>
All we did was move the premise into a local <code>assume</code>.
</p>

<p>
(By the way, the <code>assume</code> command is just alternative syntax for the
lambda symbol, so we could also have written this:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-10' mode="ace/mode/lean" readonly="true">variables A B : Prop
check (λ H : A ∧ ¬ B, and.intro (and.right H) (and.left H))
</juicy-ace-editor><div id='lean-full-code-10' style='display:none'>variables A B : Prop
check (λ H : A ∧ ¬ B, and.intro (and.right H) (and.left H))
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-10').text());">Try it yourself &raquo;</button></div>
</div>
<p>
You will learn more about the lambda symbol later.)
</p>
</div>
</div>


<div id="outline-container-org5985b4b" class="outline-3">
<h3 id="org5985b4b"><span class="section-number-3"> 4.2</span> Using <code>example</code> and <code>show</code></h3>
<div class="outline-text-3" id="text-1-2">
<p>
Let us introduce a new Lean command, <code>example</code>. This command tells
Lean that you are about to prove a theorem, or, more generally, write
down an expression of the given type. It should then be followed by
the proof or expression itself.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-11' mode="ace/mode/lean" readonly="true">variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A := 
assume H : A ∧ ¬ B, 
and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-11' style='display:none'>variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A := 
assume H : A ∧ ¬ B, 
and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-11').text());">Try it yourself &raquo;</button></div>
</div>
<p>
When given this command, Lean checks the expression after the
<code>:=</code> and makes sure it has the right type. If so, it accepts
the expression as a valid proof. If not, it raises and error.
</p>

<p>
Because the <code>example</code> command provides information as to the type of
the expression that follows (in this case, the proposition being
proved), it sometimes enables us to omit other information. For
example, we can leave off the type of the assumption:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-12' mode="ace/mode/lean" readonly="true">variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A := 
assume H, 
and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-12' style='display:none'>variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A := 
assume H, 
and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-12').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Because Lean knows we are trying to prove an implication with premise
<code>A ∧ ¬ B</code>, it can infer that when we write <code>assume H</code>, the identifier
<code>H</code> labels the assumption <code>A ∧ ¬ B</code>.
</p>

<p>
We can also go in the other direction, and provide the system with
<i>more</i> information, with the word <code>show</code>. If <code>A</code> is a proposition and
<code>P</code> is a proof, the expression "<code>show A, from P</code>" means the same
thing as <code>P</code> alone, but it signals the intention that <code>P</code> is a proof
of <code>A</code>. When Lean checks this expression, it confirms that <code>P</code> really
is a proof of <code>A</code>, before parsing the expression surrounding it. So,
in our example, we could also write:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-13' mode="ace/mode/lean" readonly="true">variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A := 
assume H : A ∧ ¬ B, 
show ¬ B ∧ A, from and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-13' style='display:none'>variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A := 
assume H : A ∧ ¬ B, 
show ¬ B ∧ A, from and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-13').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We could even annotate the smaller expressions <code>and.right H</code> and
<code>and.left H</code>, as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-14' mode="ace/mode/lean" readonly="true">variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A := 
assume H : A ∧ ¬ B, 
show ¬ B ∧ A, from and.intro 
  (show ¬ B, from and.right H) 
  (show A, from and.left H)
</juicy-ace-editor><div id='lean-full-code-14' style='display:none'>variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A := 
assume H : A ∧ ¬ B, 
show ¬ B ∧ A, from and.intro 
  (show ¬ B, from and.right H) 
  (show A, from and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-14').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This is a good place to mention that Lean generally ignores
whitespace, like indentation and returns. We could have written the
entire example on a single line. In general, we will adopt conventions
for line breaks and indentation that shows the structure of a proof
and makes it easier to read.
</p>

<p>
Although in the examples above the <code>show</code> commands were not necessary,
there are a number of good reasons to use it. First, and perhaps most
importantly, it makes the proofs easier for us humans to read. Second,
it makes the proofs easier to <i>write</i>: if you make a mistake in a
proof, it is easier for Lean to figure out where you went wrong and
provide a meaningful error message if you make your intentions
clear. Finally, proving information in the <code>show</code> clause often makes
it possible for you to omit information in other places, since Lean
can infer that information from your stated intentions.
</p>

<p>
There are notational variants. Rather than declare variables and
premises beforehand, you can also present them as "arguments" to the
example, followed by a colon:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-15' mode="ace/mode/lean" readonly="true">example (A B : Prop) : A ∧ ¬ B → ¬ B ∧ A := 
assume H : A ∧ ¬ B, 
show ¬ B ∧ A, from and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-15' style='display:none'>example (A B : Prop) : A ∧ ¬ B → ¬ B ∧ A := 
assume H : A ∧ ¬ B, 
show ¬ B ∧ A, from and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-15').text());">Try it yourself &raquo;</button></div>
</div>

<p>
There are two more tricks that can help you write proofs in Lean. The
first is using <code>sorry</code>, which is a magical term in Lean which provides
a proof of anything at all. It is also known as "cheating." But
cheating can help you construct legitimate proofs incrementally: if
Lean accepts a proof with <code>sorry</code>'s, you know that you are on the
right track so far. All you need to do is replace each <code>sorry</code> with a
real proof to finish the task.
</p>

<p>
proof is correct,
modulo the fact that each <code>sorry</code> should be replaced by a real proof.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-16' mode="ace/mode/lean" readonly="true">variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A :=
assume H, sorry

example : A ∧ ¬ B → ¬ B ∧ A :=
assume H, and.intro sorry sorry

example : A ∧ ¬ B → ¬ B ∧ A :=
assume H, and.intro (and.right H) sorry

example : A ∧ ¬ B → ¬ B ∧ A :=
assume H, and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-16' style='display:none'>variables A B : Prop

example : A ∧ ¬ B → ¬ B ∧ A :=
assume H, sorry

example : A ∧ ¬ B → ¬ B ∧ A :=
assume H, and.intro sorry sorry

example : A ∧ ¬ B → ¬ B ∧ A :=
assume H, and.intro (and.right H) sorry

example : A ∧ ¬ B → ¬ B ∧ A :=
assume H, and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-16').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The second trick is the use of <i>placeholders</i>, represented by the
underscore symbol. When you write an underscore in an expression, you
are asking the system to try to fill in the value for you. This falls
short of calling full-blown automation to prove a theorem; rather, you
are asking Lean to infer the value from the context. If you use an
underscore where a proof should be, Lean typically will <i>not</i> fill in
the proof, but it will give you an error message that tells you what
is missing. This will help you write proof terms incrementally, in a
backward-driven fashion. In the example above, try replacing each
<code>sorry</code> by an underscore, <code>_</code>, and take a look at the resulting error
messages. In each case, the error tells you what needs to be filled
in, and the variables and hypotheses that are available to you at that
stage.
</p>

<p>
One more tip: if you want to delimit the scope of variables or
premises introduced with the <code>variables</code> and <code>premises</code> commands, put
them in a block that begins with the word <code>section</code> and ends with the
word <code>end</code>. We will use this mechanism below.
</p>
</div>
</div>


<div id="outline-container-org8b48075" class="outline-3">
<h3 id="org8b48075"><span class="section-number-3"> 4.3</span> Building Natural Deduction Proofs</h3>
<div class="outline-text-3" id="text-1-3">
<p>
In this section, we describe a mechanical translation from natural
deduction proofs, by giving a translation for each natural deduction
rule. We have already seen some of the correspondences, but we repeat
them all here, for completeness.
</p>
</div>

<div id="outline-container-orge5a4b87" class="outline-4">
<h4 id="orge5a4b87"><span class="section-number-4"> 4.3.1</span> Implication</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
We have already explained that implication introduction is implemented
with <code>assume</code>, and implication elimination is written as application.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-17' mode="ace/mode/lean" readonly="true">variables A B : Prop

example : A → B :=
assume H : A, 
show B, from sorry

section
  premise P₁ : A → B
  premise P₂ : A

  example : B := P₁ P₂
end
</juicy-ace-editor><div id='lean-full-code-17' style='display:none'>variables A B : Prop

example : A → B :=
assume H : A, 
show B, from sorry

section
  premise P₁ : A → B
  premise P₂ : A

  example : B := P₁ P₂
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-17').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Since every example begins by declaring the necessary propositional
variables, we will henceforth suppress that declaration in the text.
</p>
</div>
</div>

<div id="outline-container-org1a36d6a" class="outline-4">
<h4 id="org1a36d6a"><span class="section-number-4"> 4.3.2</span> Conjunction</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
We have already seen that and introduction is implemented with
<code>and.intro</code>, and the elmination rules are <code>and.left</code> and <code>and.right</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-18' mode="ace/mode/lean" readonly="true">section 
  premises (P₁ : A) (P₂ : B)

  example : A ∧ B := and.intro P₁ P₂
end

section
  premise P : A ∧ B

  example : A := and.left P
  example : B := and.right P
end</juicy-ace-editor><div id='lean-full-code-18' style='display:none'>variables A B : Prop

section 
  premises (P₁ : A) (P₂ : B)

  example : A ∧ B := and.intro P₁ P₂
end

section
  premise P : A ∧ B

  example : A := and.left P
  example : B := and.right P
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-18').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orga5b325e" class="outline-4">
<h4 id="orga5b325e"><span class="section-number-4"> 4.3.3</span> Disjunction</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
The or introduction rules are given by <code>or.inl</code> and <code>or.inr</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-19' mode="ace/mode/lean" readonly="true">section
  premise P : A

  example : A ∨ B := or.inl P
end

section
  premise P : B

  example : A ∨ B := or.inr P
end</juicy-ace-editor><div id='lean-full-code-19' style='display:none'>variables A B : Prop

section
  premise P : A

  example : A ∨ B := or.inl P
end

section
  premise P : B

  example : A ∨ B := or.inr P
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-19').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The elimination rule is the tricky one. To prove <code>C</code> from <code>A ∨ B</code>, you
need three arguments: a proof <code>P</code> of <code>A ∨ B</code>, a proof <code>P₁</code> of <code>C</code> from
<code>A</code>, and a proof <code>P₂</code> of <code>C</code> from <code>B</code>. Using line breaks and
indentation to highlight the structure as a proof by cases, we can
write it with the following form:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-20' mode="ace/mode/lean" readonly="true">section
  premise P : A ∨ B

  example : C :=
  or.elim P
    (assume H : A, 
      show C, from sorry)
    (assume H : B, 
      show C, from sorry)
end</juicy-ace-editor><div id='lean-full-code-20' style='display:none'>variables A B C : Prop

section
  premise P : A ∨ B

  example : C :=
  or.elim P
    (assume H : A, 
      show C, from sorry)
    (assume H : B, 
      show C, from sorry)
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-20').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org2198cea" class="outline-4">
<h4 id="org2198cea"><span class="section-number-4"> 4.3.4</span> Negation</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
Internally, negation <code>¬ A</code> is defined by <code>A → false</code>, which you can
think of as saying that <code>A</code> implies something impossible. The rules
for negation are therefore similar to the rules for implication. To
prove <code>¬ A</code>, assuming <code>A</code> and derive a contradiction.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-21' mode="ace/mode/lean" readonly="true">section
  example : ¬ A :=
  assume H : A,
  show false, from sorry
end</juicy-ace-editor><div id='lean-full-code-21' style='display:none'>variable A : Prop

section
  example : ¬ A :=
  assume H : A,
  show false, from sorry
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-21').text());">Try it yourself &raquo;</button></div>
</div>
<p>
If you have proved a negation <code>¬ A</code>, you can get a contradition by
applying it to a proof of <code>A</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-22' mode="ace/mode/lean" readonly="true">section
  premise P₁ : ¬ A
  premise P₂ : A

  example : false := P₁ P₂
end</juicy-ace-editor><div id='lean-full-code-22' style='display:none'>variable A : Prop

section
  premise P₁ : ¬ A
  premise P₂ : A

  example : false := P₁ P₂
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-22').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org2d35012" class="outline-4">
<h4 id="org2d35012"><span class="section-number-4"> 4.3.5</span> Truth and falsity</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
The <i>ex falso</i> rule is called <code>false.elim</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-23' mode="ace/mode/lean" readonly="true">section
  premise P : false

  example : A := false.elim P
  example : A := false.elim P
end</juicy-ace-editor><div id='lean-full-code-23' style='display:none'>variables A : Prop

section
  premise P : false

  example : A := false.elim P
  example : A := false.elim P
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-23').text());">Try it yourself &raquo;</button></div>
</div>
<p>
There isn't much to say about <code>true</code> beyond the fact that it is
trivially true:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-24' mode="ace/mode/lean" readonly="true">example : true := trivial
</juicy-ace-editor><div id='lean-full-code-24' style='display:none'>example : true := trivial
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-24').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgd19f00c" class="outline-4">
<h4 id="orgd19f00c"><span class="section-number-4"> 4.3.6</span> Bi-implication</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
The introduction rule for "if and only if" is <code>iff.intro</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-25' mode="ace/mode/lean" readonly="true">example : A ↔ B :=
iff.intro
  (assume H : A,
    show B, from sorry)
  (assume H : B,
    show A, from sorry)</juicy-ace-editor><div id='lean-full-code-25' style='display:none'>variables A B : Prop

example : A ↔ B :=
iff.intro
  (assume H : A,
    show B, from sorry)
  (assume H : B,
    show A, from sorry)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-25').text());">Try it yourself &raquo;</button></div>
</div>
<p>
As usual, we have chosen indentation to make the structure
clear. Notice that the same label, <code>H</code>, can be used on both branches,
with a different meaning in each, because the scope of an <code>assume</code> is
limited to the expression in which it appears.
</p>

<p>
The elimination rules are <code>iff.elim_left</code> and <code>iff.elim_right</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-26' mode="ace/mode/lean" readonly="true">section
  premise P₁ : A ↔ B
  premise P₂ : A

  example : B := iff.elim_left P₁ P₂
end

section
  premise P₁ : A ↔ B
  premise P₂ : B

  example : A := iff.elim_right P₁ P₂
end</juicy-ace-editor><div id='lean-full-code-26' style='display:none'>variables A B : Prop

section
  premise P₁ : A ↔ B
  premise P₂ : A

  example : B := iff.elim_left P₁ P₂
end

section
  premise P₁ : A ↔ B
  premise P₂ : B

  example : A := iff.elim_right P₁ P₂
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-26').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org8854ee8" class="outline-4">
<h4 id="org8854ee8"><span class="section-number-4"> 4.3.7</span> Reductio ad absurdum (proof by contradiction)</h4>
<div class="outline-text-4" id="text-1-3-7">
<p>
Finally, there is the rule for proof by contradition, which we will
discuss in greater detail in <a href="#" onclick="myModule.loadTutorial('05_Classical_Reasoning.html', 'Classical_Reasoning')">Chapter 5</a>. It is included for
completeness here.
</p>

<p>
The rule is called <code>by_contradiction</code>. It has one argument, which is a
proof of <code>false</code> from <code>¬ A</code>. To use the rule, you have to ask Lean to
allow classical reasoning, by writing <code>open classical</code>. You can do
this at the beginning of the file, or any time before using it. It you
say <code>open classical</code> in a section, it will remain in scope for that section.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-27' mode="ace/mode/lean" readonly="true">section
  open classical 

  example : A :=
  by_contradiction
    (assume H : ¬ A, 
      show false, from sorry)
end</juicy-ace-editor><div id='lean-full-code-27' style='display:none'>variables A : Prop

section
  open classical 

  example : A :=
  by_contradiction
    (assume H : ¬ A, 
      show false, from sorry)
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-27').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orge92e2a1" class="outline-4">
<h4 id="orge92e2a1"><span class="section-number-4"> 4.3.8</span> Examples</h4>
<div class="outline-text-4" id="text-1-3-8">
<p>
In the last chapter, we constructed the following proof <img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_bbe5f96df5d8fe99a07b48b9da7d6fd642e3a01d.png" alt="04_Propositional_Logic_in_Lean.org.temp_bbe5f96df5d8fe99a07b48b9da7d6fd642e3a01d.png" /> from
<img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_3a9090234befeadc30f2545de2a44cc4fe6badf4.png" alt="04_Propositional_Logic_in_Lean.org.temp_3a9090234befeadc30f2545de2a44cc4fe6badf4.png" /> and <img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_8555f2ee3a9819105ee6874618b2c2045ebd7793.png" alt="04_Propositional_Logic_in_Lean.org.temp_8555f2ee3a9819105ee6874618b2c2045ebd7793.png" />:
</p>

<div class="figure">
<p><img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_f0ad34af26df3624e1b78fab309ca3005435e36f.png" alt="04_Propositional_Logic_in_Lean.org.temp_f0ad34af26df3624e1b78fab309ca3005435e36f.png" /></p>
</div>
<p>
We can model this in Lean as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-28' mode="ace/mode/lean" readonly="true">variables A B C : Prop 

premise H1 : A → B
premise H2 : B → C

example : A → C :=
assume H : A, 
show C, from H2 (H1 H)
</juicy-ace-editor><div id='lean-full-code-28' style='display:none'>variables A B C : Prop 

premise H1 : A → B
premise H2 : B → C

example : A → C :=
assume H : A, 
show C, from H2 (H1 H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-28').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that we simply declare the uncanceled hypotheses as premises.
</p>

<p>
We also constructed the following proof:
</p>

<div class="figure">
<p><img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_8cf6f283a7d2f40c1a8d587d3d57f60f50ec7b30.png" alt="04_Propositional_Logic_in_Lean.org.temp_8cf6f283a7d2f40c1a8d587d3d57f60f50ec7b30.png" /></p>
</div>
<p>
Here is how it is written in Lean:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-29' mode="ace/mode/lean" readonly="true">example (A B C : Prop) : (A → (B → C)) → (A ∧ B → C) :=
assume H1 : A → (B → C),
assume H2 : A ∧ B,
show C, from H1 (and.left H2) (and.right H2)
</juicy-ace-editor><div id='lean-full-code-29' style='display:none'>example (A B C : Prop) : (A → (B → C)) → (A ∧ B → C) :=
assume H1 : A → (B → C),
assume H2 : A ∧ B,
show C, from H1 (and.left H2) (and.right H2)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-29').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This works because <code>and.left H2</code> is a proof of <code>A</code>, and <code>and.right H2</code>
is a proof of <code>B</code>.
</p>

<p>
Finally, we constructed the following proof of <img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_07a74a8b50fae40cbf64d509f1bbce41a81252cb.png" alt="04_Propositional_Logic_in_Lean.org.temp_07a74a8b50fae40cbf64d509f1bbce41a81252cb.png" />:
</p>

<div class="figure">
<p><img src="ltximg/04_Propositional_Logic_in_Lean.org.temp_c114ab225647f5ee076dea9c3a13c37ba4b94a94.png" alt="04_Propositional_Logic_in_Lean.org.temp_c114ab225647f5ee076dea9c3a13c37ba4b94a94.png" /></p>
</div>
<p>
Here is a version in Lean:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-30' mode="ace/mode/lean" readonly="true">example (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H1 : A ∧ (B ∨ C),
or.elim (and.right H1)
  (assume H2 : B,
    show (A ∧ B) ∨ (A ∧ C), 
      from or.inl (and.intro (and.left H1) H2))
  (assume H2 : C,
    show (A ∧ B) ∨ (A ∧ C), 
      from or.inr (and.intro (and.left H1) H2))
</juicy-ace-editor><div id='lean-full-code-30' style='display:none'>example (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H1 : A ∧ (B ∨ C),
or.elim (and.right H1)
  (assume H2 : B,
    show (A ∧ B) ∨ (A ∧ C), 
      from or.inl (and.intro (and.left H1) H2))
  (assume H2 : C,
    show (A ∧ B) ∨ (A ∧ C), 
      from or.inr (and.intro (and.left H1) H2))
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-30').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In fact, bearing in mind that <code>assume</code> is alternative syntax for the
symbol <code>λ</code>, and that Lean can often infer the type of an assumption,
we can make the proof remarkably brief:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-31' mode="ace/mode/lean" readonly="true">example (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
λ H1, or.elim (and.right H1)
  (λ H2, or.inl (and.intro (and.left H1) H2))
  (λ H2, or.inr (and.intro (and.left H1) H2))
</juicy-ace-editor><div id='lean-full-code-31' style='display:none'>example (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
λ H1, or.elim (and.right H1)
  (λ H2, or.inl (and.intro (and.left H1) H2))
  (λ H2, or.inr (and.intro (and.left H1) H2))
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-31').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The proof is cryptic, though. Using such a style makes proofs hard to
write, read, understand, maintain, and debug. In the next section we
will describe a remarkably simple device that makes it much easier to
understand what is going on.
</p>
</div>
</div>
</div>


<div id="outline-container-org2177b2c" class="outline-3">
<h3 id="org2177b2c"><span class="section-number-3"> 4.4</span> Forward Reasoning</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Lean supports forward reasoning by allowing you to write proofs using
the <code>have</code> command.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-32' mode="ace/mode/lean" readonly="true">variables A B C : Prop 

premise H1 : A → B
premise H2 : B → C

example : A → C :=
assume H : A, 
have H3 : B, from H1 H,
show C, from H2 H3
</juicy-ace-editor><div id='lean-full-code-32' style='display:none'>variables A B C : Prop 

premise H1 : A → B
premise H2 : B → C

example : A → C :=
assume H : A, 
have H3 : B, from H1 H,
show C, from H2 H3
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-32').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Writing a proof with <code>have H : A, from P, ... H ...</code> has the same
effect as writing <code>... P ...</code>. This <code>have</code> command checks that <code>P</code> is
a proof of <code>A</code>, and then give you the label <code>H</code> to use in place of
<code>P</code>. Thus the last line of the previous proof can be thought of as
abbreviating <code>show C, from H2 (H1 H)</code>, since <code>H3</code> abbreviates <code>H1
H</code>. Such abbreviations can make a big difference, especially when the
proof <code>P</code> is very long.
</p>

<p>
There are a number of advantages to using <code>have</code>. For one thing, it
makes the proof more readable: the example above states <code>B</code> explicitly
as an auxiliary goal. It can also save repetition: <code>H3</code> can be used
repeatedly after it is introduced, without duplicating the
proof. Finally, it makes it easier to construct and debug the proof:
stating <code>B</code> as an auxiliary goal makes it easier for Lean to deliver
an informative error message when the goal is not properly met.
</p>

<p>
In the last section, we considered the following proof:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-33' mode="ace/mode/lean" readonly="true">example (A B C : Prop) : (A → (B → C)) → (A ∧ B → C) :=
assume H1 : A → (B → C),
assume H2 : A ∧ B,
show C, from H1 (and.left H2) (and.right H2)
</juicy-ace-editor><div id='lean-full-code-33' style='display:none'>example (A B C : Prop) : (A → (B → C)) → (A ∧ B → C) :=
assume H1 : A → (B → C),
assume H2 : A ∧ B,
show C, from H1 (and.left H2) (and.right H2)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-33').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Using <code>have</code>, it can be written more perspicuously as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-34' mode="ace/mode/lean" readonly="true">example (A B C : Prop) : (A → (B → C)) → (A ∧ B → C) :=
assume H1 : A → (B → C),
assume H2 : A ∧ B,
have H3 : A, from and.left H2,
have H4 : B, from and.right H2,
show C, from H1 H3 H4
</juicy-ace-editor><div id='lean-full-code-34' style='display:none'>example (A B C : Prop) : (A → (B → C)) → (A ∧ B → C) :=
assume H1 : A → (B → C),
assume H2 : A ∧ B,
have H3 : A, from and.left H2,
have H4 : B, from and.right H2,
show C, from H1 H3 H4
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-34').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We can be even more verbose, and add another line:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-35' mode="ace/mode/lean" readonly="true">example (A B C : Prop) : (A → (B → C)) → (A ∧ B → C) :=
assume H1 : A → (B → C),
assume H2 : A ∧ B,
have H3 : A, from and.left H2,
have H4 : B, from and.right H2,
have H5 : B → C, from H1 H3,
show C, from H5 H4
</juicy-ace-editor><div id='lean-full-code-35' style='display:none'>example (A B C : Prop) : (A → (B → C)) → (A ∧ B → C) :=
assume H1 : A → (B → C),
assume H2 : A ∧ B,
have H3 : A, from and.left H2,
have H4 : B, from and.right H2,
have H5 : B → C, from H1 H3,
show C, from H5 H4
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-35').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Adding more information doesn't always make a proof more readable;
when the individual expressions are small and easy enough to
understand, spelling them out in detail can introduce clutter. As you
learn to use Lean, you will have to develop your own style, and use
your judgment to decide which steps to make explicit.
</p>

<p>
Here is how some of the basic inferences look, when expanded with
<code>have</code>. In the and-introduction rule, it is a matter showing each
conjunct first, and then putting them together:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-36' mode="ace/mode/lean" readonly="true">example (A B : Prop) : A ∧ B → B ∧ A :=
assume H1 : A ∧ B, 
have H2 : A, from and.left H1,
have H3 : B, from and.right H1,
show B ∧ A, from and.intro H3 H2
</juicy-ace-editor><div id='lean-full-code-36' style='display:none'>example (A B : Prop) : A ∧ B → B ∧ A :=
assume H1 : A ∧ B, 
have H2 : A, from and.left H1,
have H3 : B, from and.right H1,
show B ∧ A, from and.intro H3 H2
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-36').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Compare that with this version, which instead states first that we
will use the <code>and.intro</code> rule, and then makes the two resulting goals explicit:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-37' mode="ace/mode/lean" readonly="true">example (A B : Prop) : A ∧ B → B ∧ A :=
assume H1 : A ∧ B, 
show B ∧ A, from 
  and.intro 
    (show B, from and.right H1) 
    (show A, from and.left H1)
</juicy-ace-editor><div id='lean-full-code-37' style='display:none'>example (A B : Prop) : A ∧ B → B ∧ A :=
assume H1 : A ∧ B, 
show B ∧ A, from 
  and.intro 
    (show B, from and.right H1) 
    (show A, from and.left H1)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-37').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Once again, at issue is only readability. Lean does just fine with the
following short version:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-38' mode="ace/mode/lean" readonly="true">example (A B : Prop) : A ∧ B → B ∧ A :=
λ H, and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-38' style='display:none'>example (A B : Prop) : A ∧ B → B ∧ A :=
λ H, and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-38').text());">Try it yourself &raquo;</button></div>
</div>
<p>
When using the or-elimination rule, it is often clearest to state
the relevant disjunction explicitly:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-39' mode="ace/mode/lean" readonly="true">example (A B C : Prop) : C :=
have H : A ∨ B, from sorry,
show C, from or.elim H
  (assume H1 : A,
    show C, from sorry)
  (assume H2 : B,
    show C, from sorry)
</juicy-ace-editor><div id='lean-full-code-39' style='display:none'>example (A B C : Prop) : C :=
have H : A ∨ B, from sorry,
show C, from or.elim H
  (assume H1 : A,
    show C, from sorry)
  (assume H2 : B,
    show C, from sorry)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-39').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Here is a <code>have</code>-structured presentation of an
example from the previous section:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-40' mode="ace/mode/lean" readonly="true">example (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H1 : A ∧ (B ∨ C),
have H2 : A, from and.left H1,
have H3 : B ∨ C, from and.right H1,
show (A ∧ B) ∨ (A ∧ C), from 
  or.elim H3
    (assume H4 : B,
      have H5 : A ∧ B, from and.intro H2 H4,
      show (A ∧ B) ∨ (A ∧ C), from or.inl H5)
    (assume H4 : C,
      have H5 : A ∧ C, from and.intro H2 H4,
      show (A ∧ B) ∨ (A ∧ C), from or.inr H5)
</juicy-ace-editor><div id='lean-full-code-40' style='display:none'>example (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H1 : A ∧ (B ∨ C),
have H2 : A, from and.left H1,
have H3 : B ∨ C, from and.right H1,
show (A ∧ B) ∨ (A ∧ C), from 
  or.elim H3
    (assume H4 : B,
      have H5 : A ∧ B, from and.intro H2 H4,
      show (A ∧ B) ∨ (A ∧ C), from or.inl H5)
    (assume H4 : C,
      have H5 : A ∧ C, from and.intro H2 H4,
      show (A ∧ B) ∨ (A ∧ C), from or.inr H5)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-40').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org1e30dc9" class="outline-3">
<h3 id="Definitions_and_Theorems"><a id="org1e30dc9"></a><span class="section-number-3"> 4.5</span> Definitions and Theorems</h3>
<div class="outline-text-3" id="text-Definitions_and_Theorems">
<p>
Lean allows us to name definitions and theorems for later use. For
example, here is a definition of a new "connective":
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-41' mode="ace/mode/lean" readonly="true">definition triple_and (A B C : Prop) : Prop :=
A ∧ (B ∧ C)
</juicy-ace-editor><div id='lean-full-code-41' style='display:none'>definition triple_and (A B C : Prop) : Prop :=
A ∧ (B ∧ C)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-41').text());">Try it yourself &raquo;</button></div>
</div>
<p>
As with the <code>example</code> command, it does not matter whether the
arguments <code>A</code>, <code>B</code>, and <code>C</code> are declared beforehand with the
<code>variables</code> command, or with the definition itself. We can then apply
the definition to any expressions:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-42' mode="ace/mode/lean" readonly="true">variables D E F G : Prop

check triple_and (D ∨ E) (¬ F → G) (¬ D)</juicy-ace-editor><div id='lean-full-code-42' style='display:none'>definition triple_and (A B C : Prop) : Prop :=
A ∧ (B ∧ C)

variables D E F G : Prop

check triple_and (D ∨ E) (¬ F → G) (¬ D)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-42').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Later, we will see more interesting examples of definitions, like the
following function from natural numbers to natural numbers, which
doubles its input:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-43' mode="ace/mode/lean" readonly="true">definition double (n : ℕ) : ℕ := n + n
</juicy-ace-editor><div id='lean-full-code-43' style='display:none'>definition double (n : ℕ) : ℕ := n + n
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-43').text());">Try it yourself &raquo;</button></div>
</div>

<p>
What is more interesting right now is that Lean also allows us to name
theorems, and use them later, as rules of inference. For example,
consider the following theorem:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-44' mode="ace/mode/lean" readonly="true">theorem and_comm (A B : Prop) : A ∧ B → B ∧ A :=
assume H, and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-44' style='display:none'>theorem and_comm (A B : Prop) : A ∧ B → B ∧ A :=
assume H, and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-44').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Once we have defined it, we can use it freely:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-45' mode="ace/mode/lean" readonly="true">variables C D E : Prop
premise H1 : C ∧ ¬ D
premise H2 : ¬ D ∧ C → E

example : E := H2 (and_comm C (¬ D) H1)</juicy-ace-editor><div id='lean-full-code-45' style='display:none'>theorem and_comm (A B : Prop) : A ∧ B → B ∧ A :=
assume H, and.intro (and.right H) (and.left H)

variables C D E : Prop
premise H1 : C ∧ ¬ D
premise H2 : ¬ D ∧ C → E

example : E := H2 (and_comm C (¬ D) H1)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-45').text());">Try it yourself &raquo;</button></div>
</div>
<p>
It is annoying in this example that we have to give the arguments <code>C</code>
and <code>¬ D</code> explicitly, because they are implicit in <code>H1</code>. In fact, Lean
allows us to tell this to Lean in the definition of <code>and_comm</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-46' mode="ace/mode/lean" readonly="true">theorem and_comm {A B : Prop} : A ∧ B → B ∧ A :=
assume H, and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-46' style='display:none'>theorem and_comm {A B : Prop} : A ∧ B → B ∧ A :=
assume H, and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-46').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Here the squiggly braces indicate that the arguments <code>A</code> and <code>B</code> are
<i>implicit</i>, which is to say, Lean should infer them from the context
when the theorem is used. We can then write the following instead: 
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-47' mode="ace/mode/lean" readonly="true">variables C D E : Prop
premise H1 : C ∧ ¬ D
premise H2 : ¬ D ∧ C → E

example : E := H2 (and_comm H1)</juicy-ace-editor><div id='lean-full-code-47' style='display:none'>theorem and_comm {A B : Prop} : A ∧ B → B ∧ A :=
assume H, and.intro (and.right H) (and.left H)

variables C D E : Prop
premise H1 : C ∧ ¬ D
premise H2 : ¬ D ∧ C → E

example : E := H2 (and_comm H1)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-47').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Indeed, Lean's library has a theorem, <code>and.comm</code>, defined in exactly
this way.
</p>

<p>
By the way, we could avoid the <code>assume</code> step in the proof of
<code>and.comm</code> by making the hypothesis into an argument:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-48' mode="ace/mode/lean" readonly="true">theorem and_comm {A B : Prop} (H : A ∧ B) : B ∧ A :=
and.intro (and.right H) (and.left H)
</juicy-ace-editor><div id='lean-full-code-48' style='display:none'>theorem and_comm {A B : Prop} (H : A ∧ B) : B ∧ A :=
and.intro (and.right H) (and.left H)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-48').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The two definitions yield the same result.
</p>

<p>
Definitions and theorems are important in mathematics; they allow us
to build up complex theories from fundamental principles. Instead of
the word <code>theorem</code>, you can (equivalently) use <code>lemma</code>, <code>proposition</code>,
or <code>corollary</code>.
</p>

<p>
What is interesting is that in interactive theorem proving, we can
even define familiar patterns of inference. For example, all of the
following inferences were mentioned in the last chapter:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-49' mode="ace/mode/lean" readonly="true">namespace hide

variables {A B : Prop}

theorem or_resolve_left (H1 : A ∨ B) (H2 : ¬ A) : B :=
or.elim H1
  (assume H3 : A, show B, from false.elim (H2 H3))
  (assume H3 : B, show B, from H3)

theorem or_resolve_right (H1 : A ∨ B) (H2 : ¬ B) : A :=
or.elim H1
  (assume H3 : A, show A, from H3)
  (assume H3 : B, show A, from false.elim (H2 H3))

theorem absurd (H1 : ¬ A) (H2 : A) : B :=
false.elim (H1 H2)

end hide
</juicy-ace-editor><div id='lean-full-code-49' style='display:none'>namespace hide

variables {A B : Prop}

theorem or_resolve_left (H1 : A ∨ B) (H2 : ¬ A) : B :=
or.elim H1
  (assume H3 : A, show B, from false.elim (H2 H3))
  (assume H3 : B, show B, from H3)

theorem or_resolve_right (H1 : A ∨ B) (H2 : ¬ B) : A :=
or.elim H1
  (assume H3 : A, show A, from H3)
  (assume H3 : B, show A, from false.elim (H2 H3))

theorem absurd (H1 : ¬ A) (H2 : A) : B :=
false.elim (H1 H2)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-49').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In fact, Lean's library defines <code>or.resolve_left</code>, <code>or.resolve_right</code>,
and <code>absurd</code>. We used the <code>namespace</code> command to avoid naming
conflicts, which would have raised an error.
</p>

<p>
When we ask you to prove basic facts from propositional logic in Lean,
as with propositional logic, our goal is to have you learn how to use
Lean's primitives. As a result, for those exercises, you should not
use facts from the library. As we move towards real mathematics,
however, you can use facts from the library more freely.
</p>

<p>
Let us now describe a few bells and whistles that make proofs look
prettier. for one thing, you can use subscripted numbers with a
backslash. For example, you can write <code>H₁</code> by typing <code>H\1</code>. The labels
are irrelevant to Lean, so the difference is only cosmetic.
</p>

<p>
Another feature is that you can use <code>suppose</code> instead of <code>assume</code> and
omit the label. You can then refer back to the last anonymous
assumption using the keyword <code>this</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-50' mode="ace/mode/lean" readonly="true">example : A → A ∨ B :=
suppose A,
show A ∨ B, from or.inl this</juicy-ace-editor><div id='lean-full-code-50' style='display:none'>variables A B : Prop

example : A → A ∨ B :=
suppose A,
show A ∨ B, from or.inl this
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-50').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Alternatively, you can refer back to unlabeled assumptions by putting
them in backticks:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-51' mode="ace/mode/lean" readonly="true">example : A → B → A ∧ B :=
suppose A,
suppose B, 
show A ∧ B, from and.intro `A` `B`</juicy-ace-editor><div id='lean-full-code-51' style='display:none'>variables A B : Prop

example : A → B → A ∧ B :=
suppose A,
suppose B, 
show A ∧ B, from and.intro `A` `B`
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-51').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In that case, if you prefer to use the word <code>assume</code>, you can avoid
the labels by using backticks there too:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-52' mode="ace/mode/lean" readonly="true">example : A → B → A ∧ B :=
assume `A`,
assume `B`, 
show A ∧ B, from and.intro `A` `B`</juicy-ace-editor><div id='lean-full-code-52' style='display:none'>variables A B : Prop

example : A → B → A ∧ B :=
assume `A`,
assume `B`, 
show A ∧ B, from and.intro `A` `B`
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-52').text());">Try it yourself &raquo;</button></div>
</div>

<p>
You can also use the word <code>have</code> without giving a label, and refer
back to them using the same conventions. Here is an example that uses
these features:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-53' mode="ace/mode/lean" readonly="true">theorem my_theorem {A B C : Prop} : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H : A ∧ (B ∨ C),
have A, from and.left H,
have B ∨ C, from and.right H,
show (A ∧ B) ∨ (A ∧ C), from
  or.elim `B ∨ C`
    (suppose B,
      have A ∧ B, from and.intro `A` `B`,
      show (A ∧ B) ∨ (A ∧ C), from or.inl this)
    (suppose C,
      have A ∧ C, from and.intro `A` `C`,
      show (A ∧ B) ∨ (A ∧ C), from or.inr this)
</juicy-ace-editor><div id='lean-full-code-53' style='display:none'>theorem my_theorem {A B C : Prop} : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H : A ∧ (B ∨ C),
have A, from and.left H,
have B ∨ C, from and.right H,
show (A ∧ B) ∨ (A ∧ C), from
  or.elim `B ∨ C`
    (suppose B,
      have A ∧ B, from and.intro `A` `B`,
      show (A ∧ B) ∨ (A ∧ C), from or.inl this)
    (suppose C,
      have A ∧ C, from and.intro `A` `C`,
      show (A ∧ B) ∨ (A ∧ C), from or.inr this)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-53').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Finally, you can add comments to your proofs in two ways. First, any
text after a double-dash <code>--</code> until the end of a line is ignored by
the Lean processor. Second, any text between <code>/-</code> and <code>-/</code> denotes a
block comment, and is also ignored. You can nest block comments.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-54' mode="ace/mode/lean" readonly="true">/- This is a block comment.
   It can fill multiple lines. -/

example (A : Prop) : A → A :=
suppose A,         -- assume the antecedent
show A, from this  -- use the assumption to establish the conclusion
</juicy-ace-editor><div id='lean-full-code-54' style='display:none'>/- This is a block comment.
   It can fill multiple lines. -/

example (A : Prop) : A → A :=
suppose A,         -- assume the antecedent
show A, from this  -- use the assumption to establish the conclusion
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-54').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orga41c66c" class="outline-3">
<h3 id="orga41c66c"><span class="section-number-3"> 4.6</span> Exercises</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Prove the following in Lean:
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-55' mode="ace/mode/lean" readonly="true">variables A B C D : Prop

example : A ∧ (A → B) → B :=
sorry

example : A → ¬ (¬ A ∧ B) :=
sorry

example : ¬ (A ∧ B) → (A → ¬ B) :=
sorry

example (H₁ : A ∨ B) (H₂ : A → C) (H₃ : B → D) : C ∨ D :=
sorry

example (H : ¬ A ∧ ¬ B) : ¬ (A ∨ B) :=
sorry

example : ¬ (A ↔ ¬ A) :=
sorry
</juicy-ace-editor><div id='lean-full-code-55' style='display:none'>variables A B C D : Prop

example : A ∧ (A → B) → B :=
sorry

example : A → ¬ (¬ A ∧ B) :=
sorry

example : ¬ (A ∧ B) → (A → ¬ B) :=
sorry

example (H₁ : A ∨ B) (H₂ : A → C) (H₃ : B → D) : C ∨ D :=
sorry

example (H : ¬ A ∧ ¬ B) : ¬ (A ∨ B) :=
sorry

example : ¬ (A ↔ ¬ A) :=
sorry
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-55').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
